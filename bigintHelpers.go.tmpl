{{define "bigintHelpers"}}
{{- $services := .Services -}}
{{- $opts := .Opts -}}

//
// BigInt helpers
//

// BigInt is an alias of big.Int with custom JSON (decimal string) encoding.
type BigInt big.Int

func NewBigInt(v int64) BigInt { var bi big.Int; bi.SetInt64(v); return BigInt(bi) }

// AsInt exposes the underlying *big.Int.
func (b *BigInt) AsInt() *big.Int { return (*big.Int)(b) }

// String returns the decimal string representation of the BigInt.
func (b BigInt) String() string { return b.AsInt().String() }

// MarshalText implements encoding.TextMarshaler.
func (b BigInt) MarshalText() ([]byte, error) {
	return []byte(fmt.Sprintf("\"%s\"", b.String())), nil
}

// UnmarshalText implements encoding.TextUnmarshaler.
func (b *BigInt) UnmarshalText(text []byte) error {
	if len(text) == 0 {
		return nil
	}
	if len(text) == 4 && text[0] == 'n' && string(text) == "null" {
		return nil
	}
	for _, c := range text {
		if c == ' ' || c == '\t' || c == '\n' || c == '\r' {
			return fmt.Errorf("BigInt.UnmarshalText: unexpected whitespace in %q", text)
		}
	}
	var digits []byte
	if text[0] == '-' || (text[0] >= '0' && text[0] <= '9') {
		digits = text
	} else {
		if len(text) < 2 || text[0] != '"' || text[len(text)-1] != '"' {
			return fmt.Errorf("BigInt.UnmarshalText: unsupported format %q", text)
		}
		digits = text[1 : len(text)-1]
	}
	i, ok := big.NewInt(0).SetString(string(digits), 10)
	if !ok {
		return fmt.Errorf("BigInt.UnmarshalText: failed to parse %q", text)
	}
	*b = BigInt(*i)
	return nil
}

// MarshalJSON implements json.Marshaler
func (b BigInt) MarshalJSON() ([]byte, error) {
	return b.MarshalText()
}

// UnmarshalJSON implements json.Unmarshaler
func (b *BigInt) UnmarshalJSON(text []byte) error {
	if string(text) == "null" {
		return nil
	}
	return b.UnmarshalText(text)
}

// MarshalBinary implements encoding.BinaryMarshaler. The first byte is the sign byte
// to represent positive or negative numbers.
func (b BigInt) MarshalBinary() ([]byte, error) {
	bytes := b.AsInt().Bytes()
	out := make([]byte, len(bytes)+1)
	copy(out[1:], bytes)
	if b.AsInt().Sign() < 0 {
		// Prepend a sign byte (0xFF for negative)
		out[0] = 0xFF
	} else {
		// For zero or positive numbers, prepend 0x00
		out[0] = 0x00
	}
	return out, nil
}

// UnmarshalBinary implements encoding.BinaryUnmarshaler. The first byte is the sign byte
// to represent positive or negative numbers.
func (b *BigInt) UnmarshalBinary(buff []byte) error {
	if len(buff) == 0 {
		*b = BigInt(*big.NewInt(0))
		return nil
	}
	// Extract the sign byte
	signByte := buff[0]
	i := new(big.Int)
	if len(buff) > 1 {
		i.SetBytes(buff[1:])
	}
	// Apply sign if negative
	if signByte == 0xFF {
		i.Neg(i)
	}
	*b = BigInt(*i)
	return nil
}

func (b BigInt) Value() (driver.Value, error) {
	return b.String(), nil
}

func (b *BigInt) Scan(src interface{}) error {
	if src == nil {
		return nil
	}

	var svalue string
	switch v := src.(type) {
	case string:
		svalue = v
	case []byte:
		svalue = string(v)
	default:
		return fmt.Errorf("BigInt.Scan: unexpected type %T", src)
	}

	// pgx driver returns NeX where N is digits and X is exponent
	parts := strings.SplitN(svalue, "e", 2)

	var ok bool
	i := &big.Int{}
	i, ok = i.SetString(parts[0], 10)
	if !ok {
		return fmt.Errorf("BigInt.Scan: failed to scan value %q", svalue)
	}

	if len(parts) >= 2 {
		exp := big.NewInt(0)
		exp, ok = exp.SetString(parts[1], 10)
		if !ok {
			return fmt.Errorf("BigInt.Scan failed to scan exp component %q", svalue)
		}
		i = i.Mul(i, big.NewInt(1).Exp(big.NewInt(10), exp, nil))
	}

	*b = BigInt(*i)
	return nil
}

{{end -}}
