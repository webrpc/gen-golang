{{- define "server"}}
{{- $typeMap := .TypeMap -}}
{{- $typePrefix := .TypePrefix -}}
{{- $opts := .Opts -}}

{{- if .Services -}}
//
// Server
//

{{if $opts.hooks -}}
type Config struct {
	BeforeMethod       func(ctx context.Context) error
	AfterMethodSuccess func(ctx context.Context)
	AfterMethodError   func(ctx context.Context, err WebRPCError) error
}

var defaultConfig = Config{
	BeforeMethod:       func(ctx context.Context) error { return nil },
	AfterMethodSuccess: func(ctx context.Context) {},
	AfterMethodError:   func(ctx context.Context, err WebRPCError) error { return err },
}

{{end}}

{{- range .Services}}
{{- $name := .Name -}}
{{ $serviceName := (printf "%sServer" (.Name | firstLetterToLower)) }}

{{- if $opts.hooks -}}
type {{$serviceName}} struct {
	*Config
	{{$typePrefix}}{{.Name}}
	http.Handler
}

func New{{ .Name | firstLetterToUpper }}Server(svc {{$typePrefix}}{{.Name}}, cfg *Config) *{{$serviceName}} {
	config := defaultConfig
	if cfg != nil {
		if cfg.BeforeMethod != nil {
			config.BeforeMethod = cfg.BeforeMethod
		}
		if cfg.AfterMethodSuccess != nil {
			config.AfterMethodSuccess = cfg.AfterMethodSuccess
		}
		if cfg.AfterMethodError != nil {
			config.AfterMethodError = cfg.AfterMethodError
		}
	}

	return &{{$serviceName}}{
		{{.Name}}: svc,
		Config: &config,
	}
}
{{- else -}}
type WebRPCServer interface {
	http.Handler
}

type {{$serviceName}} struct {
	{{$typePrefix}}{{.Name}}
}

func New{{ .Name | firstLetterToUpper }}Server(svc {{$typePrefix}}{{.Name}}) *{{$serviceName}} {
	return &{{$serviceName}}{
		{{.Name}}: svc,
	}
}
{{- end}}

func (s *{{$serviceName}}) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	defer func() {
		// In case of a panic, serve a HTTP 500 error and then panic.
		if rr := recover(); rr != nil {
			RespondWithError(w, ErrorWithCause(ErrWebrpcServerPanic, fmt.Errorf("%v", rr)))
			panic(rr)
		}
	}()

	ctx := r.Context()
	ctx = context.WithValue(ctx, HTTPResponseWriterCtxKey, w)
	ctx = context.WithValue(ctx, HTTPRequestCtxKey, r)
	ctx = context.WithValue(ctx, ServiceNameCtxKey, "{{.Name}}")

	var handler func(ctx context.Context, w http.ResponseWriter, r *http.Request)
	switch r.URL.Path {
	{{- range .Methods}}
	case "/rpc/{{$name}}/{{.Name}}": handler = s.serve{{.Name | firstLetterToUpper}}JSON
	{{- end}}
	default:
		err := ErrorWithCause(ErrWebrpcBadRoute, fmt.Errorf("no handler for path %q", r.URL.Path))
		RespondWithError(w, err)
		return
	}

	if r.Method != "POST" {
		w.Header().Add("Allow", "POST") // RFC 9110.
		err := ErrorWithCause(ErrWebrpcBadMethod, fmt.Errorf("unsupported method %q (only POST is allowed)", r.Method))
		RespondWithError(w, err)
		return
	}

	contentType := r.Header.Get("Content-Type")
	if i := strings.Index(contentType, ";"); i >= 0 {
		contentType = contentType[:i]
	}
	contentType = strings.TrimSpace(strings.ToLower(contentType))

	switch contentType  {
	case "application/json":
		handler(ctx, w, r)
	default:
		err := ErrorWithCause(ErrWebrpcBadRequest, fmt.Errorf("unexpected Content-Type: %q", r.Header.Get("Content-Type")))
		RespondWithError(w, err)
	}
}
{{range .Methods }}
func (s *{{$serviceName}}) serve{{ .Name | firstLetterToUpper }}JSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "{{.Name}}")

	{{if $opts.hooks -}}
	if err := s.BeforeMethod(ctx); err != nil {
		RespondWithError(w, err)
		return
	}
	{{- end}}

	{{ if gt (len .Inputs) 0 -}}
	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		rpcErr := ErrorWithCause(ErrWebrpcBadRequest, fmt.Errorf("failed to read request data: %w", err))
		RespondWithError(w, {{if $opts.hooks }}s.AfterMethodError(ctx, rpcErr){{else}}rpcErr{{end}})
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
	{{- range $i, $input := .Inputs}}
		Arg{{$i}} {{template "field" dict "Name" $input.Name "Type" $input.Type "Optional" $input.Optional "TypeMap" $typeMap "TypePrefix" $typePrefix "TypeMeta" $input.Meta "JsonTags" true}}
	{{- end}}
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		rpcErr := ErrorWithCause(ErrWebrpcBadRequest, fmt.Errorf("failed to unmarshal request data: %w", err))
		RespondWithError(w, {{if $opts.hooks }}s.AfterMethodError(ctx, rpcErr){{else}}rpcErr{{end}})
		return
	}

	{{ end -}}

	// Call service method implementation.
	{{range $i, $output := .Outputs}}ret{{$i}}, {{end}}err {{if or (eq (len .Inputs) 0) (gt (len .Outputs) 0)}}:{{end}}= s.{{$name}}.{{.Name}}(ctx{{range $i, $_ := .Inputs}}, reqPayload.Arg{{$i}}{{end}})
	if err != nil {
		{{if $opts.hooks -}}
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrorWithCause(ErrWebrpcEndpoint, err)
		}
		RespondWithError(w, s.AfterMethodError(ctx, rpcErr))
		{{else -}}
		RespondWithError(w, err)
		{{- end}}
		return
	}

	{{- if gt (len .Outputs) 0}}

	respPayload := struct {
	{{- range $i, $output := .Outputs}}
		Ret{{$i}} {{template "field" dict "Name" $output.Name "Type" $output.Type "Optional" $output.Optional "TypeMap" $typeMap "TypePrefix" $typePrefix "TypeMeta" $output.Meta "JsonTags" true}}
	{{- end}}
	}{ {{- range $i, $_ := .Outputs}}{{if gt $i 0}}, {{end}}ret{{$i}}{{end}}}
	{{- end}}

	{{- if .Outputs | len}}
	{{ if $opts.fixEmptyArrays -}}
	respBody, err := json.Marshal(initializeNilSlices(respPayload))
	{{ else -}}
	respBody, err := json.Marshal(respPayload)
	{{ end -}}
	if err != nil {
		rpcErr := ErrorWithCause(ErrWebrpcBadResponse, fmt.Errorf("failed to marshal json response: %w", err))
		RespondWithError(w, {{if $opts.hooks }}s.AfterMethodError(ctx, rpcErr){{else}}rpcErr{{end}})
		return
	}
	{{- end}}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)

	{{- if .Outputs | len}}
	w.Write(respBody)
	{{- else }}
	w.Write([]byte("{}"))
	{{- end }}

	{{- if $opts.hooks }}
	s.AfterMethodSuccess(ctx)
	{{- end}}
}
{{end}}
{{end -}}

func RespondWithError(w http.ResponseWriter, err error) {
	var rpcErr WebRPCError
	if !errors.As(err, &rpcErr) {
		rpcErr = ErrorWithCause(ErrWebrpcEndpoint, err)
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(rpcErr.HTTPStatus)

	respBody, _ := json.Marshal(err)
	w.Write(respBody)
}

{{- end -}}
{{- end -}}
